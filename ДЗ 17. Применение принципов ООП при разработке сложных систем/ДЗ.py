# Выбрать систему, которая может быть описана несколькими классами.
# Описать исползуя классы и применить принципы ООП:
# - Наследование
# - Абстрактные классы и/или интерфейсы
# - Сокрытие
# - Инкапсуляция
# У классов должно быть состояние (поля) и реализация поведения через методы.
# Требований к типам полей (экземпляра/класса) и методов (экземпляра/класса/статические) нет, по необходимости как вы видите.
# Написать код который создает необходимые экземпляры и демонстрирует работу систему.
# Ограничений на количество классов нет, но конечно их тут будет не пара.
# Это задание на это и следующие занятие. Пока советую выбрать систему, и порисовать из чего она состоит.


# Сначала объявляем абстрактный класс Figure.
# Он абстрактный потому что логика одного его поля не определена,
# значит он может использоваться только для наследования.
# Наследуем от класса фигуры класс квадрата, в котором доопределяем абстрактный метод.
# Такой класс можно использовать для получения первым аргументом ссылки не на объект, а на класс.
# Потом определяем класс куба и тоже наследуем его от фигуры. И тоже переопределяем метод получения площади.


from abc import ABC, abstractmethod


class Figure(ABC):
    def __init__(self, length: int) -> None:
        self.length = length

    @abstractmethod
    def square(self):
        pass


class Square(Figure):

    def square(self):
        sq_obj = self.length ** 2
        return sq_obj


class Cube(Figure):
    def __init__(self, length):
        super().__init__(length)
        self.square_cub = 0
        self.square_cub = [Square(length) for i in range(6)]

    def square(self):
        s = 0
        for i in self.square_cub:
            s += i.square()
        return s


cube = Cube(2)
print(cube.square())